<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´ - DriveLogger</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <link href="{{ url_for('static', filename='sessions.css') }}" rel="stylesheet">
</head>

<body>
    <div class="container">
        <a href="{{ url_for('auth.logout') }}" class="logout-link">ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ</a>
        <div style="text-align: center; margin-top: 30px;">
            <a href="{{ url_for('views.recording_start') }}" class="btn btn-custom">ãƒ¡ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«æˆ»ã‚‹</a>
        </div>
        <br>
        <h1>ã‚»ãƒƒã‚·ãƒ§ãƒ³å±¥æ­´</h1>

        {% with messages = get_flashed_messages() %}
        {% if messages %}
        <div class="alert alert-info">
            {{ messages[0] }}
        </div>
        {% endif %}
        {% endwith %}

        {% if not sessions %}
        <div class="no-sessions">
            <p>ã¾ã è¨˜éŒ²ã•ã‚ŒãŸã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>
            <p>ãƒ¡ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«æˆ»ã£ã¦è¨˜éŒ²ã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚</p>
            <a href="{{ url_for('views.recording_start') }}" class="btn btn-custom">ãƒ¡ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«æˆ»ã‚‹</a>
        </div>
        {% else %}
        {% for session in sessions %}
        <div class="session-card">
            <h3>
                ã‚»ãƒƒã‚·ãƒ§ãƒ³ID: {{ session.id }}
                <span>é–‹å§‹æ™‚åˆ»: {{ session.start_time.strftime('%Y/%m/%d %H:%M:%S') if session.start_time else 'N/A' }}</span>
                {% if session.status == 'active' %}
                <span style="color: orange; font-size: 0.8rem; margin-left: 10px;">[è¨˜éŒ²ä¸­]</span>
                {% elif session.distance is none %}
                <span style="color: red; font-size: 0.8rem; margin-left: 10px;">[æœªå®Œäº†]</span>
                {% endif %}
            </h3>
            <div class="session-details">
                <p><strong>çµ‚äº†æ™‚åˆ»ï¼š</strong> {{ session.end_time.strftime('%Y/%m/%d %H:%M:%S') if session.end_time else 'è¨˜éŒ²ä¸­' }}</p>
                <p><strong>èµ°è¡Œè·é›¢ï¼š</strong> {{ "%.2f"|format(session.distance) if session.distance is not none else 'N/A' }} km</p>
                <p><strong>æ€¥ãƒ–ãƒ¬ãƒ¼ã‚­ğŸ”´å›æ•°ï¼š</strong> {{ session.sudden_brakes if session.sudden_brakes is not none else 'N/A' }} å›</p>
                <p><strong>æ€¥ç™ºé€²ğŸŸ¢å›æ•°ï¼š</strong> {{ session.sudden_accels if session.sudden_accels is not none else 'N/A' }} å›</p>
                <p><strong>æ€¥ã‚«ãƒ¼ãƒ–ğŸŸ¡å›æ•°ï¼š</strong> {{ session.sharp_turns if session.sharp_turns is not none else 'N/A' }} å›</p>
                
                <!-- ãƒ‡ãƒãƒƒã‚°æƒ…å ± -->
                <div style="background-color: #f8f9fa; padding: 10px; margin: 10px 0; border-radius: 5px; font-size: 0.9em;">
                    <strong>ãƒ‡ãƒãƒƒã‚°æƒ…å ±:</strong><br>
                    GPS logs: {{ session.gps_logs|length if session.gps_logs else 0 }} ä»¶<br>
                    G logs: {{ session.g_logs|length if session.g_logs else 0 }} ä»¶<br>
                    Status: {{ session.status }}<br>
                    {% if session.gps_logs and session.gps_logs|length > 0 %}
                    First GPS: lat={{ session.gps_logs[0].latitude }}, lng={{ session.gps_logs[0].longitude }}<br>
                    {% endif %}
                    {% if session.g_logs and session.g_logs|length > 0 %}
                    First G: x={{ session.g_logs[0].g_x }}, y={{ session.g_logs[0].g_y }}, z={{ session.g_logs[0].g_z }}<br>
                    {% endif %}
                </div>
                
                {% if session.gps_logs|length > 0 or session.g_logs|length > 0 %}
                
                {% if session.g_logs|length > 0 %}
                <h4>GåŠ é€Ÿåº¦ï¼†é€Ÿåº¦ã‚°ãƒ©ãƒ•</h4>
                <div class="chart-container">
                    <canvas id="gForceChart-{{ session.id }}"></canvas>
                </div>
                <div style="margin-top: 10px; text-align: center;">
                    <button 
                        onmousedown="startZoom('gForceChart-{{ session.id }}', 'in')" 
                        onmouseup="stopZoom()" 
                        onmouseleave="stopZoom()" 
                        ontouchstart="startZoom('gForceChart-{{ session.id }}', 'in')" 
                        ontouchend="stopZoom()">
                        ï¼‹ Zoom In
                    </button>

                    <button 
                        onmousedown="startZoom('gForceChart-{{ session.id }}', 'out')" 
                        onmouseup="stopZoom()" 
                        onmouseleave="stopZoom()" 
                        ontouchstart="startZoom('gForceChart-{{ session.id }}', 'out')" 
                        ontouchend="stopZoom()">
                        ï¼ Zoom Out
                    </button>
                    <button onclick="resetChartZoom('gForceChart-{{ session.id }}')">
                        Reset
                    </button>
                </div>
                <div style="margin-top: 10px; text-align: center;">
                    <button id="panRight" 
                        onmousedown="startPan('gForceChart-{{ session.id }}','right')" 
                        onmouseup="stopPan()" 
                        onmouseleave="stopPan()"
                        ontouchstart="startPan('gForceChart-{{ session.id }}','right')" 
                        ontouchend="stopPan()">
                        â—€ å·¦ã¸
                    </button>

                    <button id="panLeft" 
                        onmousedown="startPan('gForceChart-{{ session.id }}','left')" 
                        onmouseup="stopPan()" 
                        onmouseleave="stopPan()"
                        ontouchstart="startPan('gForceChart-{{ session.id }}','left')" 
                        ontouchend="stopPan()">
                        å³ã¸ â–¶
                    </button>
                </div>
                {% else %}
                <div style="text-align: center; padding: 15px; background-color: #fff3cd; border-radius: 5px; margin: 10px 0;">
                    <p style="color: #856404; margin: 0;">Gã‚»ãƒ³ã‚µãƒ¼ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</p>
                </div>
                {% endif %}

                {% if session.gps_logs|length > 0 %}
                <h4>èµ°è¡Œãƒ«ãƒ¼ãƒˆã¨ã‚¤ãƒ™ãƒ³ãƒˆ</h4>
                <div class="map-container">
                    <div id="map-{{ session.id }}" style="height: 100%; width: 100%;"></div>
                </div>
                {% else %}
                <div style="text-align: center; padding: 15px; background-color: #fff3cd; border-radius: 5px; margin: 10px 0;">
                    <p style="color: #856404; margin: 0;">GPSãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“</p>
                </div>
                {% endif %}
                {% else %}
                <div class="no-data-message" style="text-align: center; padding: 20px; background-color: #f8f9fa; border-radius: 5px; margin: 10px 0;">
                    <p style="color: #6c757d; margin: 0;">ã“ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã«ã¯ã‚°ãƒ©ãƒ•ã‚„ãƒãƒƒãƒ—ã‚’è¡¨ç¤ºã™ã‚‹ãŸã‚ã®ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>
                    <small style="color: #868e96;">è¨˜éŒ²ä¸­ã¾ãŸã¯ãƒ‡ãƒ¼ã‚¿åé›†ä¸­ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</small>
                </div>
                {% endif %}

                <div class="reflection-section">
                    <h4>åçœæ–‡:</h4>
                    <textarea id="reflection-{{ session.id }}" class="reflection-textarea" rows="4"
                        placeholder="ã“ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã«ã¤ã„ã¦åçœç‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„">{{ session.reflection }}</textarea>
                    <button class="save-reflection-btn" data-session-id="{{ session.id }}">åçœæ–‡ã‚’ä¿å­˜</button>
                    <p id="save-status-{{ session.id }}" class="save-status"></p>
                </div>
                <form action="{{ url_for('views.delete_session', sid=session.id) }}" method="post"
                    onsubmit="return confirm('æœ¬å½“ã«ã“ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ');">
                    <button type="submit" class="btn btn-danger-custom">ã“ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤</button>
                </form>
            </div>
        </div>
        {% endfor %}
        {% endif %}
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        const chartInstances = {};
        let zoomInterval;
        let panInterval;
        const SAVE_REFLECTION_URL = "{{ url_for('sessions.save_reflection') }}";

        // Chart.jsã®åˆæœŸåŒ–
        let isChartReady = false;
        
        function initializeChart() {
            if (typeof Chart !== 'undefined' && !isChartReady) {
                try {
                    // Chart.registerablesãŒå­˜åœ¨ã—ã€é…åˆ—ã¾ãŸã¯iterableã‹ãƒã‚§ãƒƒã‚¯
                    if (Chart.registerables && Array.isArray(Chart.registerables)) {
                        Chart.register(...Chart.registerables);
                    } else if (Chart.registerables && typeof Chart.registerables[Symbol.iterator] === 'function') {
                        Chart.register(...Chart.registerables);
                    } else {
                        console.log('Chart.registerables not available, using default registration');
                    }
                    
                    // chartjs-plugin-zoomãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ç™»éŒ²
                    if (typeof zoomPlugin !== 'undefined') {
                        Chart.register(zoomPlugin);
                    } else if (window.ChartZoom) {
                        Chart.register(window.ChartZoom.default || window.ChartZoom);
                    }
                    
                    isChartReady = true;
                    console.log('Chart.js initialized successfully');
                } catch (error) {
                    console.error('Chart.js initialization error:', error);
                }
            }
        }
        
        // DOMèª­ã¿è¾¼ã¿æ™‚ã¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªèª­ã¿è¾¼ã¿å¾Œã®ä¸¡æ–¹ã§åˆæœŸåŒ–ã‚’è©¦è¡Œ
        document.addEventListener('DOMContentLoaded', initializeChart);
        
        // Chart.jsãŒé…å»¶èª­ã¿è¾¼ã¿ã•ã‚Œã‚‹å ´åˆã«å‚™ãˆã¦
        if (typeof Chart !== 'undefined') {
            initializeChart();
        }

        // Google Maps APIã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯é–¢æ•°ã®æ”¹å–„ç‰ˆ
        function initAllSessionMaps() {
            console.log('Google Maps API callback triggered');
            
            // Google Maps APIã®å¯ç”¨æ€§ã‚’ãƒã‚§ãƒƒã‚¯
            if (typeof google === 'undefined') {
                console.error('Google Maps API not loaded');
                setTimeout(initAllSessionMaps, 1000); // 1ç§’å¾Œã«å†è©¦è¡Œ
                return;
            }
            
            if (typeof google.maps === 'undefined') {
                console.error('Google Maps library not available');
                return;
            }
            
            console.log('Initializing all session maps...');
            
            // å„ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ãƒãƒƒãƒ—ã‚’åˆæœŸåŒ–
            {% for session in sessions %}
            {% if session.gps_logs and session.gps_logs|length > 0 %}
            try {
                const gpsLogs = {{ session.gps_logs | tojson }};
                console.log('Map data for session {{ session.id }}:', gpsLogs ? gpsLogs.length : 0, 'GPS points');
                
                if (gpsLogs && gpsLogs.length > 0) {
                    console.log('Initializing map for session {{ session.id }}');
                    initSessionMap('map-{{ session.id }}', gpsLogs);
                } else {
                    console.warn('No GPS data available for map {{ session.id }}');
                }
            } catch (error) {
                console.error('Error initializing map for session {{ session.id }}:', error);
            }
            {% else %}
            console.log('Session {{ session.id }} has no GPS data for map');
            {% endif %}
            {% endfor %}
            
            console.log('All session maps initialization completed');
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«ç¢ºå®Ÿã«è¨­å®š
        if (typeof window !== 'undefined') {
            window.initAllSessionMaps = initAllSessionMaps;
        }
        
        // å³åº§ã«åˆ©ç”¨å¯èƒ½ãªå ´åˆã¯å®Ÿè¡Œ
        if (typeof google !== 'undefined' && typeof google.maps !== 'undefined') {
            console.log('Google Maps already available, initializing immediately');
            setTimeout(initAllSessionMaps, 100);
        }

        // DOMèª­ã¿è¾¼ã¿å®Œäº†å¾Œã®å‡¦ç†
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded');
            
            // å…¨ã¦ã®ãƒãƒ£ãƒ¼ãƒˆã‚³ãƒ³ãƒ†ãƒŠã¨ãƒãƒƒãƒ—ã‚³ãƒ³ãƒ†ãƒŠã‚’å¼·åˆ¶è¡¨ç¤º
            document.querySelectorAll('.chart-container, .map-container').forEach(container => {
                container.style.display = 'block';
                container.style.visibility = 'visible';
            });
            
            console.log('All containers forced to display: block');
            
            // Chart.jsã®åˆæœŸåŒ–ã‚’ç¢ºèªã—ã¦ã‹ã‚‰ãƒãƒ£ãƒ¼ãƒˆã‚’æç”»
            function initializeCharts() {
                if (typeof Chart === 'undefined') {
                    console.log('Chart.js not yet loaded, retrying...');
                    setTimeout(initializeCharts, 200);
                    return;
                }
                
                console.log('Starting chart initialization...');
                
                // ãƒãƒ£ãƒ¼ãƒˆåˆæœŸåŒ–
                {% for session in sessions %}
                {% if session.g_logs %}
                try {
                    const gpsLogs = {{ session.gps_logs | tojson }};
                    const gLogs = {{ session.g_logs | tojson }};
                    console.log('Session {{ session.id }} data check:');
                    console.log('- GPS logs:', gpsLogs ? gpsLogs.length : 0, 'items');
                    console.log('- G logs:', gLogs ? gLogs.length : 0, 'items');
                    console.log('- Distance:', {{ session.distance if session.distance else 'null' }});
                    console.log('- Status:', '{{ session.status }}');
                    
                    if (gLogs && gLogs.length > 0) {
                        console.log('Rendering chart for session {{ session.id }}');
                        renderGForceChart('gForceChart-{{ session.id }}', gpsLogs || [], gLogs);
                    } else {
                        console.warn('No G logs available for chart {{ session.id }}');
                    }
                } catch (error) {
                    console.error('Error rendering chart for session {{ session.id }}:', error);
                }
                {% else %}
                console.log('Session {{ session.id }} has no G logs data');
                {% endif %}
                {% endfor %}
                
                console.log('All charts initialization completed');
            }
            
            // Chart.jsãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯ã—ã¦åˆæœŸåŒ–
            if (typeof Chart !== 'undefined') {
                initializeCharts();
            } else {
                setTimeout(initializeCharts, 500);
            }

            // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
            document.querySelectorAll('.session-details button').forEach(button => {
                button.addEventListener('contextmenu', e => e.preventDefault());
            });

            // åçœæ–‡ä¿å­˜ã‚¤ãƒ™ãƒ³ãƒˆ
            document.querySelectorAll('.save-reflection-btn').forEach(button => {
                button.addEventListener('click', function() {
                    const sessionId = this.dataset.sessionId;
                    const textarea = document.getElementById(`reflection-${sessionId}`);
                    const statusElement = document.getElementById(`save-status-${sessionId}`);
                    
                    statusElement.textContent = 'ä¿å­˜ä¸­...';
                    statusElement.style.color = 'gray';

                    fetch(SAVE_REFLECTION_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_id: sessionId,
                            reflection_text: textarea.value
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.status === 'ok') {
                            statusElement.textContent = 'ä¿å­˜ã—ã¾ã—ãŸï¼';
                            statusElement.style.color = 'green';
                        } else {
                            statusElement.textContent = `ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ: ${data.message}`;
                            statusElement.style.color = 'red';
                        }
                    })
                    .catch(error => {
                        statusElement.textContent = `ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${error}`;
                        statusElement.style.color = 'red';
                    });
                });
            });
        });

        // ã‚°ãƒ©ãƒ•æç”»é–¢æ•°
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ¼ã‚«ãƒ¼ã®è‰²å®šç¾©
        // === ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ¼ã‚«ãƒ¼ã®è‰²å®šç¾©ï¼ˆ8åˆ†é¡å¯¾å¿œï¼‰ ===
        const colorMap = {
            // âš ï¸ æŒ‡æ‘˜ç³»
            sudden_brake: '#ff3b30',     // èµ¤
            sudden_accel: '#34c759',     // ç·‘
            sharp_turn: '#ff9500',       // ã‚ªãƒ¬ãƒ³ã‚¸
            unstable_drive: '#ffcc00',   // é»„

            // ğŸ’™ è¤’ã‚ç³»
            smooth_turn: '#007aff',      // é’
            smooth_accel: '#5ac8fa',     // æ°´è‰²
            smooth_brake: '#4cd964',     // æ˜ã‚‹ã„ç·‘
            stable_drive: '#5856d6',     // ç´«
        };

        // ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¡¨ç¤ºã™ã‚‹å¯¾è±¡ã®è»¸
        const eventAxisMap = {
            sudden_brake: 'gz',
            sudden_accel: 'gz',
            sharp_turn: 'gx',
            speed_violation: 'speed'
        };

        // ts ã«æœ€ã‚‚è¿‘ã„ãƒ­ã‚°ã‚’æ¢ã™ï¼ˆæœ€å¤§è¨±å®¹å·®: 500msï¼‰
        function findLogByTimestamp(logs, ts, maxDiffMs = 500) {
            let closest = null;
            let minDiff = Infinity;
            logs.forEach(log => {
                const t = Number(log.timestamp_ms ?? log.timestamp);
                if (isNaN(t)) return;
                const diff = Math.abs(t - ts);
                if (diff < minDiff) {
                    closest = log;
                    minDiff = diff;
                }
            });
            return (minDiff <= maxDiffMs) ? closest : null;
        }

        // ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒˆç”Ÿæˆ
        function makeEventPoints(allTimestamps, gpsLogs, axisKey) {
            return {
                radius: allTimestamps.map(ts => {
                    const log = findLogByTimestamp(gpsLogs, ts, 500);
                    if (!log || !log.event || log.event === 'normal') return 0;
                    if (axisKey === 'speed') return 6;
                    if (eventAxisMap[log.event] === axisKey) return 6;
                    return 0;
                }),
                background: allTimestamps.map(ts => {
                    const log = findLogByTimestamp(gpsLogs, ts, 500);
                    if (!log || !log.event || log.event === 'normal') return 'transparent';
                    if (axisKey === 'speed') return colorMap[log.event] || 'gray';
                    if (eventAxisMap[log.event] === axisKey) return colorMap[log.event] || 'gray';
                    return 'transparent';
                }),
                border: allTimestamps.map(ts => {
                    const log = findLogByTimestamp(gpsLogs, ts, 500);
                    if (!log || !log.event || log.event === 'normal') return 'transparent';
                    if (axisKey === 'speed' || eventAxisMap[log.event] === axisKey) return '#000';
                    return 'transparent';
                })
            };
        }

        // ä¿®æ­£ç‰ˆã‚°ãƒ©ãƒ•æç”»é–¢æ•°
        function renderGForceChart(canvasId, gpsLogs, gLogs) {
            if (!gLogs || gLogs.length === 0) return;

            const allTimestamps = Array.from(new Set([
                ...gLogs.map(log => Number(log.timestamp_ms ?? log.timestamp)).filter(ts => !isNaN(ts)),
                ...gpsLogs.map(log => Number(log.timestamp_ms ?? log.timestamp)).filter(ts => !isNaN(ts))
            ])).sort((a, b) => a - b);

            const timestamps = allTimestamps.map(ts => new Date(ts).toLocaleTimeString('ja-JP'));

            // nullã‚’ä¿æŒã—ã¦alignã™ã‚‹ï¼ˆè£œå®Œã—ãªã„ï¼‰
            function alignData(logs, key) {
                const map = new Map(logs.map(log => [Number(log.timestamp_ms ?? log.timestamp), log[key]]));
                return allTimestamps.map(ts => {
                    const value = map.get(ts);
                    return (value !== undefined && value !== null) ? Number(value) : null;
                });
            }

            const gxData = alignData(gLogs, "g_x");
            const gyData = alignData(gLogs, "g_y");
            const gzData = alignData(gLogs, "g_z");
            const speedData = alignData(gpsLogs, "speed");  // â† ã“ã“ã‚‚ alignData ã«å¤‰æ›´

            const gxPoints = makeEventPoints(allTimestamps, gpsLogs, 'gx');
            const gyPoints = makeEventPoints(allTimestamps, gpsLogs, 'gy');
            const gzPoints = makeEventPoints(allTimestamps, gpsLogs, 'gz');
            const speedPoints = makeEventPoints(allTimestamps, gpsLogs, 'speed');

            const ctx = document.getElementById(canvasId).getContext('2d');
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timestamps,
                    datasets: [
                        {
                            label: 'å‰å¾ŒG',
                            data: gzData,
                            borderColor: '#00bcd4',
                            backgroundColor: 'rgba(0,188,212,0.2)',
                            borderWidth: 2,
                            yAxisID: 'y',
                            tension: 0,
                            spanGaps: true,
                            pointRadius: gzPoints.radius,
                            pointBackgroundColor: gzPoints.background,
                            pointBorderColor: gzPoints.border
                        },
                        {
                            label: 'ä¸Šä¸‹G',
                            data: gyData,
                            borderColor: '#666',
                            backgroundColor: 'rgba(102,102,102,0.2)',
                            borderWidth: 2,
                            yAxisID: 'y',
                            tension: 0,
                            spanGaps: true,
                            pointRadius: gyPoints.radius,
                            pointBackgroundColor: gyPoints.background,
                            pointBorderColor: gyPoints.border
                        },
                        {
                            label: 'å·¦å³G',
                            data: gxData,
                            borderColor: '#9c27b0',
                            backgroundColor: 'rgba(156,39,176,0.2)',
                            borderWidth: 2,
                            yAxisID: 'y',
                            tension: 0,
                            spanGaps: true,
                            pointRadius: gxPoints.radius,
                            pointBackgroundColor: gxPoints.background,
                            pointBorderColor: gxPoints.border
                        },
                        {
                            label: 'é€Ÿåº¦ (km/h)',
                            data: speedData,
                            borderColor: 'rgba(255,99,132,0.7)',
                            backgroundColor: 'rgba(255,99,132,0.1)',
                            borderWidth: 1,
                            yAxisID: 'y1',
                            tension: 0,
                            spanGaps: true,
                            pointStyle: ctx => speedPoints.radius[ctx.dataIndex] > 0 ? 'circle' : false,
                            pointRadius: ctx => speedPoints.radius[ctx.dataIndex],
                            pointBackgroundColor: ctx => speedPoints.background[ctx.dataIndex],
                            pointBorderColor: ctx => speedPoints.border[ctx.dataIndex]
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { position: 'left', title: { display: true, text: 'G (é‡åŠ›åŠ é€Ÿåº¦)' } },
                        y1: {
                            position: 'right',
                            title: { display: true, text: 'é€Ÿåº¦ (km/h)' },
                            grid: { drawOnChartArea: false },
                            min: 0,
                            max: 120
                        }
                    },
                    plugins: {
                        decimation: { enabled: true, algorithm: 'lttb', samples: 1000 },
                        zoom: {
                            pan: { enabled: true, mode: 'x' },
                            zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'x' }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const ts = allTimestamps[context.dataIndex];
                                    const date = new Date(ts);
                                    const timeStr = date.toLocaleTimeString('ja-JP', { hour12: false }) +
                                        "." + String(date.getMilliseconds()).padStart(3, "0");
                                    let label = `${timeStr} | ${context.dataset.label}: ${context.raw?.toFixed(2)}`;
                                    if (context.dataset.label.includes('é€Ÿåº¦')) label += ' km/h';
                                    else label += ' G';
                                    const log = gpsLogs.find(l => Number(l.timestamp_ms ?? l.timestamp) === ts);
                                    if (log && log.event && log.event !== 'normal') {
                                        label += ` (ã‚¤ãƒ™ãƒ³ãƒˆ: ${log.event.replace(/_/g, ' ')})`;
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });

            chartInstances[canvasId] = chart;
        }


        // åœ°å›³åˆæœŸåŒ–é–¢æ•°
        function initSessionMap(mapId, gpsLogs) {
            console.log('Initializing map:', mapId);
            
            if (!gpsLogs || gpsLogs.length === 0) {
                console.log('No GPS logs for map:', mapId);
                return;
            }

            const mapElement = document.getElementById(mapId);
            if (!mapElement) {
                console.error('Map element not found:', mapId);
                return;
            }

            // åœ°å›³è¦ç´ ã¨ã‚³ãƒ³ãƒ†ãƒŠã®è©³ç´°ãªè¨ºæ–­
            const container = mapElement.closest('.map-container');
            const rect = mapElement.getBoundingClientRect();
            const containerRect = container ? container.getBoundingClientRect() : null;
            
            console.log(`Map ${mapId} - Element dimensions:`, rect.width, 'x', rect.height);
            console.log(`Map ${mapId} - Container dimensions:`, containerRect ? `${containerRect.width} x ${containerRect.height}` : 'No container');
            console.log(`Map ${mapId} - Element style:`, window.getComputedStyle(mapElement).display, window.getComputedStyle(mapElement).visibility);
            
            // ã‚³ãƒ³ãƒ†ãƒŠã¨åœ°å›³è¦ç´ ã®ã‚µã‚¤ã‚ºã‚’å¼·åˆ¶çš„ã«è¨­å®š
            if (container) {
                container.style.display = 'block';
                container.style.height = '400px';
                container.style.width = '100%';
                container.style.position = 'relative';
            }
            
            mapElement.style.display = 'block';
            mapElement.style.height = '100%';
            mapElement.style.width = '100%';
            mapElement.style.position = 'relative';
            
            // å†åº¦å¯¸æ³•ã‚’ãƒã‚§ãƒƒã‚¯
            const newRect = mapElement.getBoundingClientRect();
            console.log(`Map ${mapId} - After resize:`, newRect.width, 'x', newRect.height);
            
            if (newRect.width === 0 || newRect.height === 0) {
                console.error(`Map ${mapId} still has zero dimensions after resize attempt`);
                // å†è©¦è¡Œ
                setTimeout(() => initSessionMap(mapId, gpsLogs), 200);
                return;
            }

            if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
                console.error('Google Maps API not available');
                mapElement.innerHTML = '<p style="text-align: center; margin-top: 20px; color: red;">åœ°å›³ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚</p>';
                return;
            }

            try {
                const path = gpsLogs.map(log => ({ lat: log.latitude, lng: log.longitude }));
                const map = new google.maps.Map(mapElement, {
                    zoom: 15,
                    center: path[0]
                });
                
                // åœ°å›³ã®èª­ã¿è¾¼ã¿å®Œäº†å¾Œã«ãƒªã‚µã‚¤ã‚ºã‚’ãƒˆãƒªã‚¬ãƒ¼
                google.maps.event.addListenerOnce(map, 'idle', function() {
                    console.log(`Map ${mapId} is idle, triggering resize`);
                    google.maps.event.trigger(map, 'resize');
                });

                new google.maps.Polyline({
                    path: path,
                    geodesic: true,
                    strokeColor: '#007bff',
                    strokeOpacity: 1.0,
                    strokeWeight: 4,
                    map: map
                });

                // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ¼ã‚«ãƒ¼
                gpsLogs.forEach(log => {
                    if (log.event && log.event !== 'normal') {
                        const colors = {
                            'sudden_brake': 'red',
                            'sudden_accel': 'green',
                            'sharp_turn': 'orange',
                            'speed_violation': 'purple'
                        };
                        
                        new google.maps.Marker({
                            position: { lat: log.latitude, lng: log.longitude },
                            map: map,
                            icon: {
                                path: google.maps.SymbolPath.CIRCLE,
                                scale: 6,
                                fillColor: colors[log.event] || 'gray',
                                fillOpacity: 1,
                                strokeWeight: 1,
                                strokeColor: '#000'
                            },
                            title: log.event.replace('_', ' ')
                        });
                    }
                });
                
                console.log('Map initialized successfully:', mapId);
            } catch (error) {
                console.error('Error creating map:', mapId, error);
                mapElement.innerHTML = '<p style="text-align: center; margin-top: 20px; color: red;">åœ°å›³ã®åˆæœŸåŒ–ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚</p>';
            }
        }

        // ã‚ºãƒ¼ãƒ ãƒ»ãƒ‘ãƒ³é–¢æ•°
        function startZoom(canvasId, direction) {
            const chart = chartInstances[canvasId];
            if (!chart) return;
            
            const factor = 1.05;
            zoomInterval = setInterval(() => {
                if (direction === 'in') {
                    chart.zoom({ x: factor, y: 1 });
                } else if (direction === 'out') {
                    chart.zoom({ x: 1 / factor, y: 1 });
                }
            }, 150);
        }

        function stopZoom() {
            if (zoomInterval) {
                clearInterval(zoomInterval);
                zoomInterval = null;
            }
        }

        function startPan(canvasId, direction) {
            const chart = chartInstances[canvasId];
            if (!chart) return;
            
            const distance = direction === 'left' ? -50 : 50;
            panInterval = setInterval(() => {
                chart.pan({ x: distance, y: 0 });
            }, 100);
        }

        function stopPan() {
            if (panInterval) {
                clearInterval(panInterval);
                panInterval = null;
            }
        }

        function resetChartZoom(canvasId) {
            const chart = chartInstances[canvasId];
            if (chart) {
                chart.resetZoom();
            }
        }

    </script>
    
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBUyc6mj-SEOP8lopM2laEywMILL8qknvo&callback=initAllSessionMaps&loading=async"></script>
</body>
</html>